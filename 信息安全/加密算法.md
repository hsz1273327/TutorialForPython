
# 加密算法

加密算法基本可以分为两种:

+ 对称加密

+ 非对称加密


非对称加密有很高的安全性,但是和对称加密比起来,它非常的慢,所以我们还是要用对称加密来传送消息.

但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去.

[PyCrypto](https://www.dlitz.net/software/pycrypto/doc/)是一个python的密码学工具,它提供了多种加密算法,我们可以直接使用.它有以下这些模块:

+ Crypto.Hash 摘要算法
+ Crypto.Random 随机模块
+ Crypto.Cipher 对称加密算法
+ Crypto.PublicKey 非对称加密

下文为最常见的对称加密和非对称加密算法的例子

# 对称加密(Symmetric Cryptography)

对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。
对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。

最常见的对称加密算法就是AES算法了

一般对称加密有如下几种模式

+ MODE_ECB 电码本模式(Electronic Codebook)
    
    这种模式是将整个明文分成若干段相同的小段，然后对每一小段进行加密

    优点:
    
    1. 简单； 
    2. 有利于并行计算； 
    3. 误差不会被传送；
    
    
    缺点: 
    
    1. 不能隐藏明文的模式； 
    2. 可能对明文进行主动攻击； 

+ MODE_CBC = 2 密码分组链接模式（Cipher Block Chaining)

    这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。

    优点：
    
    1. 不容易主动攻击,安全性好于ECB,适合传输长度长的报文,是SSL、IPSec的标准。 
　　 
   
    缺点：
    
    1. 不利于并行计算； 
    2. 误差传递； 
    3. 需要初始化向量IV 
    
+ MODE_CFB = 3 密码反馈模式（Cipher FeedBack)


    优点： 
    
    1. 隐藏了明文模式; 
    2. 分组密码转化为流模式; 
    3. 可以及时加密传送小于分组的数据;
    
    缺点: 
    
    1. 不利于并行计算; 
    2. 误差传送：一个明文单元损坏影响多个单元; 
    3. 唯一的IV; 


+ MODE_OFB = 5

    输出反馈模式(Output FeedBack)

    优点:
    
    1. 隐藏了明文模式;
    2. 分组密码转化为流模式; 
    3. 可以及时加密传送小于分组的数据; 
    
    
    缺点: 
    
    1. 不利于并行计算;
    2. 对明文的主动攻击是可能的; 
    3. 误差传送：一个明文单元损坏影响多个单元; 

+ MODE_CTR = 6 计数器模式（Counter)
    
    计算器模式不常见，在CTR模式中， 有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是 在计算器不能维持很长的情况下，密钥只能使用一次

+ MODE_OPENPGP = 7 OpenPGP 模式

### AES

AES算法,即高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一



```python
from Crypto.Cipher import AES
from Crypto import Random
key = 'This is a key123'

iv = Random.new().read(AES.block_size)#iv,AES需要block_size = 16位的随机bytes
iv
```




    b'H\t\x80X\xbe|\x7f\x1e\xace8~\x91?\xc0P'




```python
obj = AES.new(key, AES.MODE_CBC, iv)
message = "The answer is no"
ciphertext = obj.encrypt(message)
ciphertext
```




    b'\xf3\x80L\x1cV9D\x17L\xe1Igb\xda\x9c\xee'




```python
obj2 = AES.new(key, AES.MODE_CBC, iv)
obj2.decrypt(ciphertext)
```




    b'The answer is no'



### DES

DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来


```python
from Crypto.Cipher import DES
key = 'abcdefgh'
obj=DES.new(key, DES.MODE_ECB)
message="Guido van Rossum is a space alien."
len(message)
```




    34



DES的加密数据长度必须是8的整数倍


```python
ciph=obj.encrypt(message+'XXXXXX')# 加密
ciph
```




    b'\x11,\xe3Nq\x8cDY\xdfT\xe2pA\xfa\xad\xc9s\x88\xf3,\xc0j\xd8\xa8\xca\xe7\xe2I\xd15w\x1d61\xc3dgb/\x06'




```python
obj.decrypt(ciph)
```




    b'Guido van Rossum is a space alien.XXXXXX'



# 非对称加密

非对称加密是当今世界用的最多的一种加密形式,它使用一对秘钥而不是一个秘钥来实现加密解密,
这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）

他们的用法如下图

![非对称加密的流程](img/crypto.jpg)

简单说就是发送方用接收方的公钥加密数据,接收方再用自己的私钥解码数据,因此两个人要加密交流必须各自都有公钥私钥,然后相互交换过公钥才行

## RSA

常见的非对称加密算法是RSA

RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥.具体的算法介绍可以看[阮一峰的这篇介绍文](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

### 生成秘钥


```python
from Crypto.PublicKey import RSA
from Crypto import Random
```


```python
random_generator = Random.new().read
random_generator
```




    <bound method RNGFile.read of <Crypto.Random._UserFriendlyRNG.RNGFile object at 0x10c674630>>




```python
key = RSA.generate(2048,random_generator)# rsa算法生成实例
```


```python
# 秘钥对的生成
private_pem = key.exportKey()
```


```python
private_pem
```




    b'-----BEGIN RSA PRIVATE KEY-----\nMIIEpQIBAAKCAQEA4CfM+MJLzygGFes8BtnH6Vu8rYRbWbFQQSTq5v4qU9LNi0bG\nFHxfKjHleA9i+lwZcPRfvQtv89TC4RN8uudZ4UCKEpYwEli6x+7Bu4xYa1x3PHSg\nv/YL7yoaeXHl5wrXPE9UoTvgiP4JWJ9+4+FuXRUMApkcKhSckgJXM5yyfFB/Gt9K\nWbsa29zbKWdI5Q3TklVUaid147rUcQen0yfJ1t5LptcHSnndCYBOfGwttDzv5yAs\nfaa0q0xq5hDqFlxJvXWx68eqhia24wImpqWu9JzGLZxOgmUwtEzN7x7NdWXTPHql\ny/bVLu8GqFGdB9D5/MKz4Wku6CpEGCM/duH15wIDAQABAoIBAQDWucnEUnvEihaq\nUJlEBsNWbCamIbBQj2bNwMu1U6zAd6Om07lUTn/rL7kd9b9fDXLhnXdI5Pftn9a/\nPaeyc4TKHsUlYPHT4WOruq+jNaJN1lnyc9a5jL2J8c9CnzUYym28vFHZ0j4ZfSD+\n4GrxaTYLvOmwY3NzbCNASzW1n1nrcnV+OeiG0Lb3lZUJ0TiHXAI1ZMn47ov0LEdP\nbFxeR3Up7LguKveUc6PLH6b4lviy4Qbf96f8ZdiNJSkHjPm0rL0j3ZPWaE/cZzvE\nawk+nMZQ/DJq1in1oQvzRQQgsGl81Ix3xpu/ni46uUjMur7Vb5Kev39xmUzMNiVz\nDpsUOp5BAoGBAONtYqlYmoJkpp4Mhv+ZxhZ4zUaaPwCKIVhli+U/Q/MvWKtiIN5U\nzpzTrXDdcwPyVolF/tbmgcPKZ+M16h3oWuBDHMds0uMnHpWxodrD0TLH3038hiE7\nxtZ19ETALn6vGHQihtf4jKEyWn2ECrjxD5+hQGF4dT4XKlriDDJ8UO5vAoGBAPxR\nL4xu8Zi1iJ9npwqsjnCtZOPi05wDGgykdwffP0eicQykiq8rFyWH1lkDHU2JOpMO\na16s5UaIAenYJ3HkWgnHfKeKJRUfW4sFA+u+I3VyjpP5I0VzEeSGutP2RbgbA0xb\n2i51gUaHSlKr2u5EI4c4J5dzHI+6RDsN+zMBGawJAoGAP+6E+KP+sz8GE5Hj9UBO\nDg0hb4J2yXkLDKVnISeau2cI3wyzvqxKdI2QyRSHe4mJSAeULucXfWmNsLJ8QLIL\nsdVL5sextMdPcrc/j5bSXRsQrASb1AXQzILWCumXaGdiUWtPSrEFH19fTr9qoDir\nsq0Kwxuwoaazcl7vHNYTjiMCgYEA7m4hiolEUFQrOMcQOKv7JksULayo3qKnuQ6p\nVI0IFT9RqOrMCt+jTdnhGdgxlpV4/oH/wEWNm2rms/2IuL1awCb8iq2mgSFStjoV\nDG5uv4tzZC1nwTcNz2/pmGb+Vw1fvoaF1KVBdk5eU2UGy2UkVaEg+KLUeJVB6LQ7\njmUZx1ECgYEAxJpbacrbNjEHazmMDmNwqBsqF2qvC+jnPD8QbwqefTUENiJeOzwd\nQPwvAQAI3GD5FlUF2EjjRR/cNoAnU3UBk3csCvIu/XD40cZABdF+hn3EGQyqko3n\ntZlgjrxAKu6Pq4eClxqaYuTSNk7dvU0rLmbdZx8C8svfLlLZMeyCvME=\n-----END RSA PRIVATE KEY-----'




```python
public_pem = key.publickey().exportKey()
public_pem
```




    b'-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4CfM+MJLzygGFes8BtnH\n6Vu8rYRbWbFQQSTq5v4qU9LNi0bGFHxfKjHleA9i+lwZcPRfvQtv89TC4RN8uudZ\n4UCKEpYwEli6x+7Bu4xYa1x3PHSgv/YL7yoaeXHl5wrXPE9UoTvgiP4JWJ9+4+Fu\nXRUMApkcKhSckgJXM5yyfFB/Gt9KWbsa29zbKWdI5Q3TklVUaid147rUcQen0yfJ\n1t5LptcHSnndCYBOfGwttDzv5yAsfaa0q0xq5hDqFlxJvXWx68eqhia24wImpqWu\n9JzGLZxOgmUwtEzN7x7NdWXTPHqly/bVLu8GqFGdB9D5/MKz4Wku6CpEGCM/duH1\n5wIDAQAB\n-----END PUBLIC KEY-----'



### 加密


```python
from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5
import base64
```


```python
message = 'hello , this is a test text'
```


```python
rsakey = RSA.importKey(public_pem)
cipher = Cipher_pkcs1_v1_5.new(rsakey)#加密
cipher_text = base64.b64encode(cipher.encrypt(message.encode("utf-8")))#序列化
cipher_text
```




    b'BXD6hPYLRHFZPRKS8k+BLM7MdhVJd95H81AAHOlpDtoiNVY0kx9M6+bovp2lJNnCQQW7SdXgUa3jU3tc75x7lhKWw/+ZqdPZLa7u4lD+cvz4gsT3XzTxvjd7mB0KFnoUrsR/x+3/R1X0IuBksZoQfXhtEd4Mtadikj2NSLEFxYxxfS8iZz0Ds4Cq8/nY2bw9a8o70hXJPyiLTlt2e2sIWQpBUq/lgA6zDrtgt92TQFAAWG+iy9DM8Jmj5O5lEiL47XO2rD5h5GWtTG+mkhUfLkmdw01ekf541AZAPEaGjvkkuju56r77vgVELw9pWbfIriu0BaAXXLk7q+2dnGzPpA=='



### 解密




```python
rsakey = RSA.importKey(private_pem)
cipher = Cipher_pkcs1_v1_5.new(rsakey)
text = cipher.decrypt(base64.b64decode(cipher_text), random_generator)#解密
text
```




    b'hello , this is a test text'



我们将这对钥匙保存起来


```python
with open('source/private.pem', 'wb') as f:
    f.write(private_pem)
```


```python
with open('source/public_pem', 'wb') as f:
    f.write(public_pem)
```
